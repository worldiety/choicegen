// Code generated by choice; DO NOT EDIT

package {{.Package}}

{{if .HasFmt}}
    import(
        "fmt"
       )
{{end}}

{{range .ChoiceTypes}}
    {{- makeComment .Doc -}}
    type {{.Name}} interface {
        // {{joinIdents .Choices}}
        {{range .SubsetOf}}
            is{{.}}() bool // marker method for {{.}}
        {{end}}

        {{range .Funcs}}
                    {{.Name}}({{joinParams .Params}}) ({{joinParams .Results}})
        {{end}}
    }
{{end}}

{{range $member := .MemberTypes}}
    // {{$member.Name}} is one of interface { {{joinIdents $member.BelongsTo}} }
    {{range $member.BelongsTo}}
        func (_ {{$member.Name}}) is{{.}}() bool { return true }
    {{end}}

    {{if $member.Error}}
        func ({{$member.ShortName}} {{$member.Name}}) Error() string { return fmt.Sprintf("%T: %s",{{$member.ShortName}},{{$member.ShortName}}.String()) }
    {{end}}
{{end}}

{{range .ChoiceTypes}}
    // Match{{.Name}} checks each type case and panics either if choiceType is nil or if an interface compatible
    // type has been passed but is not part of the sum type specification.
    // Each case must be handled and evaluate properly, so nil functions will panic.
    func Match{{.Name}}[R any](choiceType {{.Name}}, {{range .Choices}}match{{.}} func({{.}})R,{{end}})R{
        switch t:=choiceType.(type){
                {{- range .Choices}}
                case {{.}}:
                    return match{{.}}(t)
                {{- end -}}
        }

        panic(fmt.Sprintf("%T is not part of the choice type {{.Name}}",choiceType))
    }
{{end}}
